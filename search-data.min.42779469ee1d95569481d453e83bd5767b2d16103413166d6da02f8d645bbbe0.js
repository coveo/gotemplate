(function(){const pages=[{"idx":0,"href":"/gotemplate/docs/basics/cli_usage/","title":"CLI Usage","content":"usage: ./gotemplate [\u0026lt;flags\u0026gt;] \u0026lt;command\u0026gt; [\u0026lt;args\u0026gt; ...] An extended template processor for go. See: https://coveo.github.io/gotemplate for complete documentation. Flags: -h, --help Show context-sensitive help (also try --help-man). or set _GOTEMPLATE_HELP --color Force rendering of colors event if output is redirected or set _GOTEMPLATE_COLOR (alias: --c) -v, --version Get the current version of gotemplate --base Turn off all addons (they could then be enabled explicitly) or set _GOTEMPLATE_BASE --razor Razor Addon (ON by default) or set _GOTEMPLATE_RAZOR (off: --no-razor) --extension Extension Addon (ON by default) or set _GOTEMPLATE_EXTENSION (alias: --ext) (off: --next, --no-ext, --no-extension) --math Math Addon (ON by default) or set _GOTEMPLATE_MATH (off: --no-math) --sprig Sprig Addon (ON by default) or set _GOTEMPLATE_SPRIG (off: --no-sprig) --data Data Addon (ON by default) or set _GOTEMPLATE_DATA (off: --no-data) --logging Logging Addon (ON by default) or set _GOTEMPLATE_LOGGING (off: --no-logging) --runtime Runtime Addon (ON by default) or set _GOTEMPLATE_RUNTIME (off: --no-runtime) --utils Utils Addon (ON by default) or set _GOTEMPLATE_UTILS (off: --no-utils) --net Net Addon (ON by default) or set _GOTEMPLATE_NET (off: --nnet, --no-net) --os OS Addon (ON by default) or set _GOTEMPLATE_OS (off: --no-os, --nos) Args: [\u0026lt;templates\u0026gt;] Template files or commands to process Commands: help [\u0026lt;command\u0026gt;...] Show help. run [\u0026lt;flags\u0026gt;] [\u0026lt;templates\u0026gt;...] --delimiters={{,}},@ Define the default delimiters for go template (separate the left, right and razor delimiters by a comma) or set _GOTEMPLATE_DELIMITERS (alias: --d, --del) -i, --import=file ... Import variables files (could be any of YAML, JSON or HCL format) or set _GOTEMPLATE_IMPORT --import-if-exist=file ... Import variables files (do not consider missing file as an error) or set _GOTEMPLATE_IMPORT_IF_EXIST (alias: --iie) -V, --var=values ... Import named variables (if value is a file, the content is loaded) or set _GOTEMPLATE_VAR -t, --type=TYPE Force the type used for the main context (Json, Yaml, Hcl) or set _GOTEMPLATE_TYPE -p, --patterns=pattern ... Additional patterns that should be processed by gotemplate or set _GOTEMPLATE_PATTERNS -e, --exclude=pattern ... Exclude file patterns (comma separated) when applying gotemplate recursively or set _GOTEMPLATE_EXCLUDE -o, --overwrite Overwrite file instead of renaming them if they exist (required only if source folder is the same as the target folder) or set _GOTEMPLATE_OVERWRITE -s, --substitute=exp ... Substitute text in the processed files by applying the regex substitute expression (format: /regex/substitution, the first character acts as separator like in sed, see: Go regexp) or set _GOTEMPLATE_SUBSTITUTE -E, --remove-empty-lines Remove empty lines from the result or set _GOTEMPLATE_REMOVE_EMPTY_LINES (alias: --re, --rel, --remove-empty) -r, --recursive Process all template files recursively or set _GOTEMPLATE_RECURSIVE -R, --recursion-depth=depth Process template files recursively specifying depth or set _GOTEMPLATE_RECURSION_DEPTH (alias: --rd) --source=folder Specify a source folder (default to the current folder) or set _GOTEMPLATE_SOURCE (alias: --s) --target=folder Specify a target folder (default to source folder) or set _GOTEMPLATE_TARGET (alias: --t) -I, --stdin Force read of the standard input to get a template definition (useful only if GOTEMPLATE_NO_STDIN is set) or set _GOTEMPLATE_STDIN -f, --follow-symlinks Follow the symbolic links while using the recursive option or set _GOTEMPLATE_FOLLOW_SYMLINKS (alias: --fs) -P, --print Output the result directly to stdout or set _GOTEMPLATE_PRINT -d, --disable Disable go template rendering (used to view razor conversion) or set _GOTEMPLATE_DISABLE --accept-no-value Do not consider rendering \u0026lt;no value\u0026gt; as an error or set GOTEMPLATE_NO_VALUE (alias: --anv, --no-value, --nv) -S, --strict-error-validation Consider error encountered in any file as real error or set GOTEMPLATE_STRICT_ERROR (alias: --sev, --strict) -L, --log-level=level Set the logging level CRITICAL (0), ERROR (1), WARNING (2), NOTICE (3), INFO (4), DEBUG (5) or set _GOTEMPLATE_LOG_LEVEL (alias: --ll) --debug-log-level=level Set the debug logging level 0-9 or set _GOTEMPLATE_DEBUG_LOG_LEVEL (alias: --debug-level, --dl, --dll) --log-simple Disable the extended logging, i.e. no color, no date or set _GOTEMPLATE_LOG_SIMPLE (alias: --ls) --ignore-missing-import Exit with code 0 even if import does not exist or set _GOTEMPLATE_IGNORE_MISSING_IMPORT (alias: --imi) --ignore-missing-source Exit with code 0 even if source does not exist or set _GOTEMPLATE_IGNORE_MISSING_SOURCE (alias: --ims) --ignore-missing-paths Exit with code 0 even if import or source do not exist or set _GOTEMPLATE_IGNORE_MISSING_PATHS (alias: --imp) list [\u0026lt;flags\u0026gt;] [\u0026lt;filters\u0026gt;...] Get detailed help on gotemplate functions -f, --functions Get detailed help on function -t, --templates List the available templates -l, --long Get detailed list -a, --all List all -c, --category Group functions by category  "},{"idx":1,"href":"/gotemplate/docs/basics/","title":"Basics","content":""},{"idx":2,"href":"/gotemplate/docs/features/","title":"Features","content":""},{"idx":3,"href":"/gotemplate/docs/structs/","title":"Structs","content":""},{"idx":4,"href":"/gotemplate/","title":"","content":" gotemplate   \nDescription Apply go template over files ending with .template in the current directory.\nFor more information on Go Template functionality, check this link.\nThis little utility just scan the current folder for *.template files and apply the go template over them.\nEvery matching *.ext.template file will render a file named *.generated.ext. Other matched file (if \u0026ndash;pattern is supplied) will replace the file with the rendered content and rename the original file *.ext.original.\nDocumentation\n"},{"idx":5,"href":"/gotemplate/docs/basics/functions/","title":"Functions","content":"Base go template functions and gt le not println call html len or urlquery eq index lt print ge js ne printf Data Conversion data toHcl toPrettyJson toQuotedTFVars hcl toInternalHcl toPrettyTFVars toTFVars json toJson toQuotedHcl toYaml toBash toPrettyHcl toQuotedJson yaml Data Manipulation String extract key pluck undef append get keys prepend union array hasKey lenc rest unique bool initial list reverse unset char intersect merge safeIndex values contains isNil omit set without content isSet pick slice dict isZero pickv string Logging critical error info panic debug fatal notice warning Mathematic Bit Operations band bor lshift bclear bxor rshift Mathematic Fundamental add div floor pow trunc cbrt exp mod pow10 ceil exp2 modf rem dim expm1 mul sub Mathematic Stats avg max min Mathematic Trigonometry acos atanh j1 logb tanh acosh cos jn rad y0 asin cosh log sin y1 asinh deg log10 sincos yn atan ilogb log1p sinh atan2 j0 log2 tan Mathematic Utilities abs gamma isInf lgamma sqrt dec hex isNaN nextAfter to frexp hypot ldexp signBit until Net httpDoc httpGet Operating systems functions diff home isReadable mode stat exists isDir isWriteable pwd user glob isExecutable lastMod save username group isFile lookPath size Other utilities center formatList indent mergeList sIndent color id joinLines nIndent splitLines concat iif lorem repeat wrap Runtime alias categories func getSignature substitute aliases current function include templateNames allFunctions ellipsis functions localAlias templates assert exec getAttributes raise assertWarning exit getMethods run Sprig Cryptographic \u0026amp; Security http://masterminds.github.io/sprig/crypto.html adler32sum derivePassword genPrivateKey genSignedCert sha256sum buildCustomCert genCA genSelfSignedCert sha1sum Sprig Date http://masterminds.github.io/sprig/date.html ago dateInZone htmlDate now date dateModify htmlDateInZone toDate Sprig Default http://masterminds.github.io/sprig/defaults.html coalesce default ternarySprig toPrettyJsonSprig compact empty toJsonSprig Sprig Dictionnary http://masterminds.github.io/sprig/dicst.html dictSprig listSprig omitSprig setSprig hasKeySprig mergeOverwrite pickSprig unsetSprig keysSprig mergeSprig pluckSprig valuesSprig Sprig Encoding http://masterminds.github.io/sprig/encoding.html b32dec b32enc b64dec b64enc Sprig File Path http://masterminds.github.io/sprig/paths.html base clean dir ext isAbs Sprig Flow Control http://masterminds.github.io/sprig/flow_control.html fail Sprig General http://masterminds.github.io/sprig/ hello uuidv4 Sprig List http://masterminds.github.io/sprig/lists.html appendSprig initialSprig restSprig uniqSprig first last reverseSprig withoutSprig hasSprig prependSprig sliceSprig Sprig Mathematics http://masterminds.github.io/sprig/math.html add1 divSprig minSprig round addSprig floorSprig modSprig subSprig ceilSprig maxSprig mulSprig untilStep Sprig OS http://masterminds.github.io/sprig/defaults.html env expandenv Sprig Reflection http://masterminds.github.io/sprig/reflection.html kindIs kindOf typeIs typeIsLike typeOf Sprig Regex http://masterminds.github.io/sprig/strings.html regexFind regexMatch regexReplaceAllLiteral regexFindAll regexReplaceAll regexSplit Sprig String Slice http://masterminds.github.io/sprig/string_slice.html join split splitn sortAlpha splitList toStrings Sprig Strings http://masterminds.github.io/sprig/strings.html abbrev initials randAlphaNum substr truncSprig abbrevboth kebabcase randAscii swapcase untitle camelcase lower randNumeric title upper cat nindentSprig repeatSprig toString wrapSprig containsSprig nospace replace trim wrapWith hasPrefix plural shuffle trimAll hasSuffix quote snakecase trimPrefix indentSprig randAlpha squote trimSuffix Sprig Type Conversion http://masterminds.github.io/sprig/conversion.html atoi float64 int64 intSprig Sprig Version comparison http://masterminds.github.io/sprig/semver.html semver semverCompare  "},{"idx":6,"href":"/gotemplate/docs/basics/functions_long/","title":"Functions Long","content":" Functions Base go template functions // Returns the boolean AND of its arguments by returning the first empty argument or the last argument, that is, \u0026quot;and x y\u0026quot; behaves as \u0026quot;if x then y else x\u0026quot;. All the arguments are evaluated. func and(arg0 reflect.Value, args ...reflect.Value) reflect.Value  // Returns the result of calling the first argument, which must be a function, with the remaining arguments as parameters. Thus \u0026quot;call .X.Y 1 2\u0026quot; is, in Go notation, dot.X.Y(1, 2) where Y is a func-valued field, map entry, or the like. The first argument must be the result of an evaluation that yields a value of function type (as distinct from a predefined function such as print). The function must return either one or two result values, the second of which is of type error. If the arguments don't match the function or the returned error value is non-nil, execution stops. func call(fn reflect.Value, args ...reflect.Value) reflect.Value, error)  // Returns the boolean truth of arg1 == arg2 func eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)  // Returns the boolean truth of arg1 \u0026gt;= arg2 func ge(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)  // Returns the boolean truth of arg1 \u0026gt; arg2 func gt(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)  // Returns the escaped HTML equivalent of the textual representation of its arguments. This function is unavailable in html/template, with a few exceptions. func html(args ...interface{}) string  // Returns the result of indexing its first argument by the following arguments. Thus \u0026quot;index x 1 2 3\u0026quot; is, in Go syntax, x[1][2][3]. Each indexed item must be a map, slice, or array. func index(item reflect.Value, indices ...reflect.Value) (reflect.Value, error)  // Returns the escaped JavaScript equivalent of the textual representation of its arguments. func js(args ...interface{}) string  // Returns the boolean truth of arg1 \u0026lt;= arg2 func le(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)  // Returns the integer length of its argument. func len(item interface{}) (int, error)  // Returns the boolean truth of arg1 \u0026lt; arg2 func lt(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)  // Returns the boolean truth of arg1 != arg2 func ne(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error)  // Returns the boolean negation of its single argument. func not(not(arg reflect.Value) bool  // Returns the boolean OR of its arguments by returning the first non-empty argument or the last argument, that is, \u0026quot;or x y\u0026quot; behaves as \u0026quot;if x then x else y\u0026quot;. All the arguments are evaluated. func or(or(arg0 reflect.Value, args ...reflect.Value) reflect.Value  // An alias for fmt.Sprint func print(args ...interface{}) string  // An alias for fmt.Sprintf func printf(format string, args ...interface{}) string  // An alias for fmt.Sprintln func println(args ...interface{}) string  // Returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. This function is unavailable in html/template, with a few exceptions. func urlquery(args ...interface{}) string  Data Conversion // Tries to convert the supplied data string into data structure (Go spec). It will try to convert HCL, YAML and JSON format. If context is omitted, default context is used. // Aliases: DATA, fromData, fromDATA func data(data interface{}, context ...interface{}) interface{}, error  // Converts the supplied hcl string into data structure (Go spec). If context is omitted, default context is used. // Aliases: HCL, fromHcl, fromHCL, tfvars, fromTFVars, TFVARS, fromTFVARS func hcl(hcl interface{}, context ...interface{}) interface{}, error  // Converts the supplied json string into data structure (Go spec). If context is omitted, default context is used. // Aliases: JSON, fromJson, fromJSON func json(json interface{}, context ...interface{}) interface{}, error  // Converts the supplied value to bash compatible representation. func toBash(value interface{}) string  // Converts the supplied value to compact HCL representation. // Aliases: toHCL func toHcl(value interface{}) string, error  // Converts the supplied value to compact HCL representation used inside outer HCL definition. // Aliases: toInternalHCL, toIHCL, toIHcl func toInternalHcl(value interface{}) string, error  // Converts the supplied value to compact JSON representation. // Aliases: toJSON func toJson(value interface{}) string, error  // Converts the supplied value to pretty HCL representation. // Aliases: toPrettyHCL func toPrettyHcl(value interface{}) string, error  // Converts the supplied value to pretty JSON representation. // Aliases: toPrettyJSON func toPrettyJson(value interface{}) string, error  // Converts the supplied value to pretty HCL representation (without multiple map declarations). func toPrettyTFVars(value interface{}) string, error  // Converts the supplied value to compact quoted HCL representation. // Aliases: toQuotedHCL func toQuotedHcl(value interface{}) string, error  // Converts the supplied value to compact quoted JSON representation. // Aliases: toQuotedJSON func toQuotedJson(value interface{}) string, error  // Converts the supplied value to compact HCL representation (without multiple map declarations). func toQuotedTFVars(value interface{}) string, error  // Converts the supplied value to compact HCL representation (without multiple map declarations). func toTFVars(value interface{}) string, error  // Converts the supplied value to YAML representation. // Aliases: toYAML func toYaml(value interface{}) string, error  // Converts the supplied yaml string into data structure (Go spec). If context is omitted, default context is used. // Aliases: YAML, fromYaml, fromYAML func yaml(yaml interface{}, context ...interface{}) interface{}, error  Data Manipulation // Returns a String class object that allows invoking standard string operations as method. func String(value interface{}) String  // Append new items to an existing list, creating a new list. // Aliases: push func append(list interface{}, elements ...interface{}) IGenericList, error  // Ensures that the supplied argument is an array (if it is already an array/slice, there is no change, if not, the argument is replaced by []interface{} with a single value). func array(value interface{}) interface{}  // Converts the `string` into boolean value (`string` must be `True`, `true`, `TRUE`, `1` or `False`, `false`, `FALSE`, `0`) func bool(str string) bool, error  // Returns the character corresponging to the supplied integer value func char(value interface{}) interface{}, error  // Test to see if a list has a particular elements. // Aliases: has func contains(list interface{}, elements ...interface{}) bool, error  // Returns the content of a single element map (used to retrieve content in a declaration like `value \u0026quot;name\u0026quot; { a = 1 b = 3}`) func content(keymap interface{}) interface{}, error  // Returns a new dictionary from a list of pairs (key, value). // Aliases: dictionary func dict(args ...interface{}) IDictionary, error  // Extracts values from a slice or a map, indexes could be either integers for slice or strings for maps func extract(source interface{}, indexes ...interface{}) interface{}, error  // Returns the value associated with the supplied map, key and map could be inverted for convenience (i.e. when using piping mode) func get(map interface{}, key interface{}, default ...interface{}) interface{}, error  // Returns true if the dictionary contains the specified key. func hasKey(dictionary interface{}, key interface{}) interface{}, error  // Returns but the last element. func initial(list interface{}) interface{}, error  // Returns a list that is the intersection of the list and all arguments (removing duplicates). func intersect(list interface{}, elements ...interface{}) IGenericList, error  // Returns true if the supplied value is nil. // Aliases: isNull func isNil(arg1 interface{}) bool  // Returns true if the supplied value is not nil. func isSet(arg1 interface{}) bool  // Returns true if the supplied value is false, 0, nil or empty. // Aliases: isEmpty func isZero(arg1 interface{}) bool  // Returns the key name of a single element map (used to retrieve name in a declaration like `value \u0026quot;name\u0026quot; { a = 1 b = 3}`) func key(value interface{}) interface{}, error  // Returns a list of all of the keys in a dict (in alphabetical order). func keys(dictionary IDictionary) IGenericList  // Returns the number of actual character in a string. // Aliases: nbChars func lenc(str string) int  // Returns a generic list from the supplied arguments. // Aliases: tuple func list(args ...interface{}) IGenericList  // Merges two or more dictionaries into one, giving precedence to the dest dictionary. func merge(destination IDictionary, sources IDictionary, args ...IDictionary) IDictionary  // Returns a new dict with all the keys that do not match the given keys. func omit(dict IDictionary, keys interface{}, args ...interface{}) IDictionary  // Selects just the given keys out of a dictionary, creating a new dict. func pick(dict IDictionary, keys ...interface{}) IDictionary  // Same as pick, but returns an error message if there are intruders in supplied dictionary. func pickv(dict IDictionary, message string, keys interface{}, args ...interface{}) interface{}, error  // Extracts a list of values matching the supplied key from a list of dictionary. func pluck(key interface{}, dictionaries ...IDictionary) IGenericList  // Push elements onto the front of a list, creating a new list. func prepend(list interface{}, elements ...interface{}) IGenericList, error  // Gets the tail of the list (everything but the first item) func rest(list interface{}) interface{}, error  // Produces a new list with the reversed elements of the given list. func reverse(list interface{}) IGenericList, error  // Returns the element at index position or default if index is outside bounds. func safeIndex(value interface{}, index int, default interface{}) interface{}, error  // Adds the value to the supplied map using key as identifier. func set(dict interface{}, key interface{}, value interface{}) string, error  // Returns a slice of the supplied object (equivalent to object[from:to]). func slice(value interface{}, args ...interface{}) interface{}, error  // Converts the supplied value into its string representation. func string(value interface{}) string  // Returns the default value if value is not set, alias `undef` (differs from Sprig `default` function as empty value such as 0, false, \u0026quot;\u0026quot; are not considered as unset). // Aliases: ifUndef func undef(default interface{}, values ...interface{}) interface{}  // Returns a list that is the union of the list and all arguments (removing duplicates). func union(list interface{}, elements ...interface{}) IGenericList, error  // Generates a list with all of the duplicates removed. // Aliases: uniq func unique(list interface{}) IGenericList, error  // Removes an element from a dictionary. // Aliases: delete, remove func unset(dictionary interface{}, key interface{}) string, error  func values(arg1 IDictionary) IGenericList  // Filters items out of a list. func without(list interface{}, elements ...interface{}) IGenericList, error  Logging // Logs a message using CRITICAL as log level (0). // Aliases: criticalf func critical(args ...interface{}) string  // Logs a message using DEBUG as log level (5). // Aliases: debugf func debug(args ...interface{}) string  // Logs a message using ERROR as log level (1). // Aliases: errorf func error(args ...interface{}) string  // Equivalents to critical followed by a call to os.Exit(1). // Aliases: fatalf func fatal(args ...interface{}) string  // Logs a message using INFO as log level (4). // Aliases: infof func info(args ...interface{}) string  // Logs a message using NOTICE as log level (3). // Aliases: noticef func notice(args ...interface{}) string  // Equivalents to critical followed by a call to panic. // Aliases: panicf func panic(args ...interface{}) string  // Logs a message using WARNING as log level (2). // Aliases: warn, warnf, warningf func warning(args ...interface{}) string  Mathematic Bit Operations // Aliases: bitwiseAND func band(arg1 interface{}, arg2 interface{}, args ...interface{}) interface{}, error  // Aliases: bitwiseClear func bclear(arg1 interface{}, arg2 interface{}, args ...interface{}) interface{}, error  // Aliases: bitwiseOR func bor(arg1 interface{}, arg2 interface{}, args ...interface{}) interface{}, error  // Aliases: bitwiseXOR func bxor(arg1 interface{}, arg2 interface{}, args ...interface{}) interface{}, error  // Aliases: leftShift func lshift(arg1 interface{}, arg2 interface{}) interface{}, error  // Aliases: rightShift func rshift(arg1 interface{}, arg2 interface{}) interface{}, error  Mathematic Fundamental // Aliases: sum func add(arg1 interface{}, args ...interface{}) interface{}, error  // Returns the cube root of x. // Special cases are: // cbrt(±0) = ±0 // cbrt(±Inf) = ±Inf // cbrt(NaN) = NaN func cbrt(x interface{}) interface{}, error  // Returns the least integer value greater than or equal to x. // Special cases are: // ceil(±0) = ±0 // ceil(±Inf) = ±Inf // ceil(NaN) = NaN // Aliases: roundUp, roundup func ceil(x interface{}) interface{}, error  // Returns the maximum of x-y or 0. // Special cases are: // dim(+Inf, +Inf) = NaN // dim(-Inf, -Inf) = NaN // dim(x, NaN) = dim(NaN, x) = NaN func dim(x interface{}, y interface{}) interface{}, error  // Aliases: divide, quotient func div(arg1 interface{}, arg2 interface{}) interface{}, error  // Returns e**x, the base-e exponential of x. // Special cases are: // exp(+Inf) = +Inf // exp(NaN) = NaN // Very large values overflow to 0 or +Inf. Very small values underflow to 1. // Aliases: exponent func exp(x interface{}) interface{}, error  // Returns 2**x, the base-2 exponential of x. // Special cases are the same as exp. // Aliases: exponent2 func exp2(x interface{}) interface{}, error  // Returns e**x - 1, the base-e exponential of x minus 1. It is more // accurate than exp(x) - 1 when x is near zero. // Special cases are: // expm1(+Inf) = +Inf // expm1(-Inf) = -1 // expm1(NaN) = NaN // Very large values overflow to -1 or +Inf func expm1(x interface{}) interface{}, error  // Returns the greatest integer value less than or equal to x. // Special cases are: // floor(±0) = ±0 // floor(±Inf) = ±Inf // floor(NaN) = NaN // Aliases: roundDown, rounddown, int, integer func floor(x interface{}) interface{}, error  // Returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x. // Special cases are: // mod(±Inf, y) = NaN // mod(NaN, y) = NaN // mod(x, 0) = NaN // mod(x, ±Inf) = x // mod(x, NaN) = NaN // Aliases: modulo func mod(x interface{}, y interface{}) interface{}, error  // Returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f. // Special cases are: // modf(±Inf) = ±Inf, NaN // modf(NaN) = NaN, NaN func modf(f interface{}) interface{}, error  // Aliases: multiply, prod, product func mul(arg1 interface{}, args ...interface{}) interface{}, error  // Returns x**y, the base-x exponential of y. // Special cases are (in order): // pow(x, ±0) = 1 for any x // pow(1, y) = 1 for any y // pow(x, 1) = x for any x // pow(NaN, y) = NaN // pow(x, NaN) = NaN // pow(±0, y) = ±Inf for y an odd integer \u0026lt; 0 // pow(±0, -Inf) = +Inf // pow(±0, +Inf) = +0 // pow(±0, y) = +Inf for finite y \u0026lt; 0 and not an odd integer // pow(±0, y) = ±0 for y an odd integer \u0026gt; 0 // pow(±0, y) = +0 for finite y \u0026gt; 0 and not an odd integer // pow(-1, ±Inf) = 1 // pow(x, +Inf) = +Inf for |x| \u0026gt; 1 // pow(x, -Inf) = +0 for |x| \u0026gt; 1 // pow(x, +Inf) = +0 for |x| \u0026lt; 1 // pow(x, -Inf) = +Inf for |x| \u0026lt; 1 // pow(+Inf, y) = +Inf for y \u0026gt; 0 // pow(+Inf, y) = +0 for y \u0026lt; 0 // pow(-Inf, y) = Pow(-0, -y) // pow(x, y) = NaN for finite x \u0026lt; 0 and finite non-integer y // Aliases: power func pow(x interface{}, y interface{}) interface{}, error  // Returns 10**n, the base-10 exponential of n. // Special cases are: // pow10(n) =0 for n \u0026lt; -323 // pow10(n) = +Inf for n \u0026gt; 308 // Aliases: power10 func pow10(n interface{}) interface{}, error  // Returns the IEEE 754 floating-point remainder of x/y. // Special cases are: // rem(±Inf, y) = NaN // rem(NaN, y) = NaN // rem(x, 0) = NaN // rem(x, ±Inf) = x // rem(x, NaN) = NaN // Aliases: remainder func rem(arg1 interface{}, arg2 interface{}) interface{}, error  // Aliases: subtract func sub(arg1 interface{}, arg2 interface{}) interface{}, error  // Returns the integer value of x. // Special cases are: // trunc(±0) = ±0 // trunc(±Inf) = ±Inf // trunc(NaN) = NaN // Aliases: truncate func trunc(x interface{}) interface{}, error  Mathematic Stats // Aliases: average func avg(arg1 interface{}, args ...interface{}) interface{}, error  // Returns the larger of x or y. // Special cases are: // max(x, +Inf) = max(+Inf, x) = +Inf // max(x, NaN) = max(NaN, x) = NaN // max(+0, ±0) = max(±0, +0) = +0 // max(-0, -0) = -0 // Aliases: maximum, biggest func max(x ...interface{}) interface{}  // Returns the smaller of x or y. // Special cases are: // min(x, -Inf) = min(-Inf, x) = -Inf // min(x, NaN) = min(NaN, x) = NaN // min(-0, ±0) = min(±0, -0) = -0 // Aliases: minimum, smallest func min(x ...interface{}) interface{}  Mathematic Trigonometry // Returns the arccosine, in radians, of x. // Special case is: // acos(x) = NaN if x \u0026lt; -1 or x \u0026gt; 1 // Aliases: arcCosine, arcCosinus func acos(x interface{}) interface{}, error  // Returns the inverse hyperbolic cosine of x. // Special cases are: // acosh(+Inf) = +Inf // acosh(x) = NaN if x \u0026lt; 1 // acosh(NaN) = NaN // Aliases: arcHyperbolicCosine, arcHyperbolicCosinus func acosh(x interface{}) interface{}, error  // Returns the arcsine, in radians, of x. // Special cases are: // asin(±0) = ±0 // asin(x) = NaN if x \u0026lt; -1 or x \u0026gt; 1 // Aliases: arcSine, arcSinus func asin(x interface{}) interface{}, error  // Returns the inverse hyperbolic sine of x. // Special cases are: // asinh(±0) = ±0 // asinh(±Inf) = ±Inf // asinh(NaN) = NaN // Aliases: arcHyperbolicSine, arcHyperbolicSinus func asinh(x interface{}) interface{}, error  // Returns the arctangent, in radians, of x. // Special cases are: // atan(±0) = ±0 // atan(±Inf) = ±Pi/2 // Aliases: arcTangent func atan(x interface{}) interface{}, error  // Returns the arc tangent of y/x, using the signs of the two to determine the quadrant of the return value. // Special cases are (in order): // atan2(y, NaN) = NaN // atan2(NaN, x) = NaN // atan2(+0, x\u0026gt;=0) = +0 // atan2(-0, x\u0026gt;=0) = -0 // atan2(+0, x\u0026lt;=-0) = +Pi // atan2(-0, x\u0026lt;=-0) = -Pi // atan2(y\u0026gt;0, 0) = +Pi/2 // atan2(y\u0026lt;0, 0) = -Pi/2 // atan2(+Inf, +Inf) = +Pi/4 // atan2(-Inf, +Inf) = -Pi/4 // atan2(+Inf, -Inf) = 3Pi/4 // atan2(-Inf, -Inf) = -3Pi/4 // atan2(y, +Inf) = 0 // atan2(y\u0026gt;0, -Inf) = +Pi // atan2(y\u0026lt;0, -Inf) = -Pi // atan2(+Inf, x) = +Pi/2 // atan2(-Inf, x) = -Pi/2 // Aliases: arcTangent2 func atan2(x interface{}, y interface{}) interface{}, error  // Returns the inverse hyperbolic tangent of x. // Special cases are: // atanh(1) = +Inf // atanh(±0) = ±0 // atanh(-1) = -Inf // atanh(x) = NaN if x \u0026lt; -1 or x \u0026gt; 1 // atanh(NaN) = NaN // Aliases: arcHyperbolicTangent func atanh(x interface{}) interface{}, error  // Returns the cosine of the radian argument x. // Special cases are: // cos(±Inf) = NaN // cos(NaN) = NaN // Aliases: cosine, cosinus func cos(x interface{}) interface{}, error  // Returns the hyperbolic cosine of x. // Special cases are: // cosh(±0) = 1 // cosh(±Inf) = +Inf // cosh(NaN) = NaN // Aliases: hyperbolicCosine, hyperbolicCosinus func cosh(x interface{}) interface{}, error  // Aliases: degree func deg(arg1 interface{}) interface{}, error  // Returns the binary exponent of x as an integer. // Special cases are: // ilogb(±Inf) = MaxInt32 // ilogb(0) = MinInt32 // ilogb(NaN) = MaxInt32 func ilogb(x interface{}) interface{}, error  // Returns the order-zero Bessel function of the first kind. // Special cases are: // j0(±Inf) = 0 // j0(0) = 1 // j0(NaN) = NaN // Aliases: firstBessel0 func j0(x interface{}) interface{}, error  // Returns the order-one Bessel function of the first kind. // Special cases are: // j1(±Inf) = 0 // j1(NaN) = NaN // Aliases: firstBessel1 func j1(x interface{}) interface{}, error  // Returns the order-n Bessel function of the first kind. // Special cases are: // jn(n, ±Inf) = 0 // jn(n, NaN) = NaN // Aliases: firstBesselN func jn(n interface{}, x interface{}) interface{}, error  // Returns the natural logarithm of x. // Special cases are: // log(+Inf) = +Inf // log(0) = -Inf // log(x \u0026lt; 0) = NaN // log(NaN) = NaN func log(x interface{}) interface{}, error  // Returns the decimal logarithm of x. The special cases are the same as for log. func log10(x interface{}) interface{}, error  // Returns the natural logarithm of 1 plus its argument x. It is more accurate than log(1 + x) when x is near zero. // Special cases are: // log1p(+Inf) = +Inf // log1p(±0) = ±0 // log1p(-1) = -Inf // log1p(x \u0026lt; -1) = NaN // log1p(NaN) = NaN func log1p(x interface{}) interface{}, error  // Returns the binary logarithm of x. The special cases are the same as for log. func log2(x interface{}) interface{}, error  // Returns the binary exponent of x. // Special cases are: // logb(±Inf) = +Inf // logb(0) = -Inf // logb(NaN) = NaN func logb(x interface{}) interface{}, error  // Aliases: radian func rad(arg1 interface{}) interface{}, error  // Returns the sine of the radian argument x. // Special cases are: // sin(±0) = ±0 // sin(±Inf) = NaN // sin(NaN) = NaN // Aliases: sine, sinus func sin(x interface{}) interface{}, error  // Returns Sin(x), Cos(x). // Special cases are: // sincos(±0) = ±0, 1 // sincos(±Inf) = NaN, NaN // sincos(NaN) = NaN, NaN // Aliases: sineCosine, sinusCosinus func sincos(x interface{}) interface{}, error  // Returns the hyperbolic sine of x. // Special cases are: // sinh(±0) = ±0 // sinh(±Inf) = ±Inf // sinh(NaN) = NaN // Aliases: hyperbolicSine, hyperbolicSinus func sinh(x interface{}) interface{}, error  // Returns the tangent of the radian argument x. // Special cases are: // tan(±0) = ±0 // tan(±Inf) = NaN // tan(NaN) = NaN // Aliases: tangent func tan(x interface{}) interface{}, error  // Returns the hyperbolic tangent of x. // Special cases are: // tanh(±0) = ±0 // tanh(±Inf) = ±1 // tanh(NaN) = NaN // Aliases: hyperbolicTangent func tanh(x interface{}) interface{}, error  // Returns the order-zero Bessel function of the second kind. // Special cases are: // y0(+Inf) = 0 // y0(0) = -Inf // y0(x \u0026lt; 0) = NaN // y0(NaN) = NaN // Aliases: secondBessel0 func y0(x interface{}) interface{}, error  // Returns the order-one Bessel function of the second kind. // Special cases are: // y1(+Inf) = 0 // y1(0) = -Inf // y1(x \u0026lt; 0) = NaN // y1(NaN) = NaN // Aliases: secondBessel1 func y1(x interface{}) interface{}, error  // Returns the order-n Bessel function of the second kind. // Special cases are: // yn(n, +Inf) = 0 // yn(n ≥ 0, 0) = -Inf // yn(n \u0026lt; 0, 0) = +Inf if n is odd, -Inf if n is even // yn(n, x \u0026lt; 0) = NaN // yn(n, NaN) = NaN // Aliases: secondBesselN func yn(n interface{}, x interface{}) interface{}, error  Mathematic Utilities // Returns the absolute value of x. // Special cases are: // abs(±Inf) = +Inf // abs(NaN) = NaN // Aliases: absolute func abs(x interface{}) interface{}, error  // Aliases: decimal func dec(arg1 interface{}) interface{}, error  // Breaks f into a normalized fraction and an integral power of two. Returns frac and exp satisfying f == frac × 2**exp, with the absolute value of frac in the interval [½, 1). // Special cases are: // frexp(±0) = ±0, 0 // frexp(±Inf) = ±Inf, 0 // frexp(NaN) = NaN, 0 func frexp(f interface{}) interface{}, error  // Returns the Gamma function of x. // Special cases are: // gamma(+Inf) = +Inf // gamma(+0) = +Inf // gamma(-0) = -Inf // gamma(x) = NaN for integer x \u0026lt; 0 // gamma(-Inf) = NaN // gamma(NaN) = NaN func gamma(x interface{}) interface{}, error  // Aliases: hexa, hexaDecimal func hex(arg1 interface{}) interface{}, error  // Returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow. // Special cases are: // hypot(±Inf, q) = +Inf // hypot(p, ±Inf) = +Inf // hypot(NaN, q) = NaN // hypot(p, NaN) = NaN // Aliases: hypotenuse func hypot(p interface{}, q interface{}) interface{}, error  // Reports whether f is an infinity, according to sign. If sign \u0026gt; 0, isInf reports whether f is positive infinity. If sign \u0026lt; 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity // Aliases: isInfinity func isInf(f interface{}, arg2 interface{}) interface{}, error  // Reports whether f is an IEEE 754 'not-a-number' value func isNaN(f interface{}) interface{}, error  // Ldexp is the inverse of Frexp. Returns frac × 2**exp. // Special cases are: // ldexp(±0, exp) = ±0 // ldexp(±Inf, exp) = ±Inf // ldexp(NaN, exp) = NaN func ldexp(frac interface{}, exp interface{}) interface{}, error  // Returns the natural logarithm and sign (-1 or +1) of Gamma(x). // Special cases are: // lgamma(+Inf) = +Inf // lgamma(0) = +Inf // lgamma(-integer) = +Inf // lgamma(-Inf) = -Inf // lgamma(NaN) = NaN func lgamma(x interface{}) interface{}, error  // Returns the next representable float64 value after x towards y. // Special cases are: // Nextafter(x, x) = x // Nextafter(NaN, y) = NaN // Nextafter(x, NaN) = NaN func nextAfter(arg1 interface{}, arg2 interface{}) interface{}, error  func signBit(arg1 interface{}, arg2 interface{}) interface{}, error  // Returns the square root of x. // Special cases are: // sqrt(+Inf) = +Inf // sqrt(±0) = ±0 // sqrt(x \u0026lt; 0) = NaN // sqrt(NaN) = NaN // Aliases: squareRoot func sqrt(x interface{}) interface{}, error  func to(args ...interface{}) interface{}, error  func until(args ...interface{}) interface{}, error  Net // Returns http document returned by supplied URL. // Aliases: httpDocument, curl func httpDoc(url interface{}) interface{}, error  // Returns http get response from supplied URL. func httpGet(url interface{}) *http.Response, error  Operating systems functions // Returns a colored string that highlight differences between supplied texts. // Aliases: difference func diff(text1 interface{}, text2 interface{}) interface{}  // Determines if a file exists or not. // Aliases: fileExists, isExist func exists(filename interface{}) bool, error  // Returns the expanded list of supplied arguments (expand *[]? on filename). // Aliases: expand func glob(args ...interface{}) IGenericList  // Returns the current user group information (user.Group object). // Aliases: userGroup func group() *user.Group, error  // Returns the home directory of the current user. // Aliases: homeDir, homeFolder func home() string  // Determines if the file is a directory. // Aliases: isDirectory, isFolder func isDir(filename interface{}) bool, error  // Determines if the file is executable by the current user. func isExecutable(filename interface{}) bool, error  // Determines if the file is a file (i.e. not a directory). func isFile(filename interface{}) bool, error  // Determines if the file is readable by the current user. func isReadable(filename interface{}) bool, error  // Determines if the file is writeable by the current user. func isWriteable(filename interface{}) bool, error  // Returns the last modification time of the file. // Aliases: lastModification, lastModificationTime func lastMod(filename interface{}) time.Time, error  // Returns the location of the specified executable (returns empty string if not found). // Aliases: whereIs, look, which, type func lookPath(arg1 interface{}) string  // Returns the file mode. // Aliases: fileMode func mode(filename interface{}) os.FileMode, error  // Returns the current working directory. // Aliases: currentDir func pwd() string  // Save object to file. // Aliases: write, writeTo func save(filename string, object interface{}) string, error  // Returns the file size. // Aliases: fileSize func size(filename interface{}) int64, error  // Returns the file Stat information (os.Stat object). // Aliases: fileStat func stat(arg1 string) os.FileInfo, error  // Returns the current user information (user.User object). // Aliases: currentUser func user() *user.User, error  // Returns the current user name. func username() string  Other utilities // Returns the concatenation of supplied arguments centered within width. // Aliases: centered func center(width interface{}, args ...interface{}) string, error  // Colors the rendered string. // // The first arguments are interpretated as color attributes until the first non color attribute. Attributes are case insensitive. // // Valid attributes are: // Reset, Bold, Faint, Italic, Underline, BlinkSlow, BlinkRapid, ReverseVideo, Concealed, CrossedOut // // Valid color are: // Black, Red, Green, Yellow, Blue, Magenta, Cyan, White // // Color can be prefixed by: // Fg: Meaning foreground (Fg is assumed if not specified) // FgHi: Meaning high intensity forground // Bg: Meaning background\u0026quot; // BgHi: Meaning high intensity background // Aliases: colored, enhanced func color(args ...interface{}) string, error  // Returns the concatenation (without separator) of the string representation of objects. func concat(args ...interface{}) string  // Return a list of strings by applying the format to each element of the supplied list. // // You can also use autoWrap as Razor expression if you don't want to specify the format. // The format is then automatically induced by the context around the declaration). // Valid aliases for autoWrap are: aWrap, awrap. // // Ex: // Hello @\u0026lt;autoWrap(to(10)) World! // Aliases: autoWrap, aWrap, awrap func formatList(format string, list ...interface{}) IGenericList  // Returns a valid go identifier from the supplied string (replacing any non compliant character by replacement, default _ ). // Aliases: identifier func id(identifier string, replaceChar ...interface{}) string  // If testValue is empty, returns falseValue, otherwise returns trueValue. // WARNING: All arguments are evaluated and must by valid. // Aliases: ternary func iif(testValue interface{}, valueTrue interface{}, valueFalse interface{}) interface{}  // Indents every line in a given string to the specified indent width. This is useful when aligning multi-line strings. func indent(nbSpace int, args ...interface{}) string  // Merge the supplied objects into a newline separated string. func joinLines(format ...interface{}) string  // Returns a random string. Valid types are be word, words, sentence, para, paragraph, host, email, url. // Aliases: loremIpsum func lorem(loremType interface{}, params ...int) string, error  // Return a single list containing all elements from the lists supplied. func mergeList(lists ...IGenericList) IGenericList  // Aliases: nindent func nIndent(nbSpace int, args ...interface{}) string  // Returns an array with the item repeated n times. func repeat(n int, element interface{}) IGenericList, error  // Indents the elements using the provided spacer. // // You can also use autoIndent as Razor expression if you don't want to specify the spacer. // Spacer will then be auto determined by the spaces that precede the expression. // Valid aliases for autoIndent are: aIndent, aindent. // Aliases: sindent, spaceIndent, autoIndent, aindent, aIndent func sIndent(spacer string, args ...interface{}) string  // Returns a list of strings from the supplied object with newline as the separator. func splitLines(content interface{}) []interface{}  // Wraps the rendered arguments within width. // Aliases: wrapped func wrap(width interface{}, args ...interface{}) string, error  Runtime // Defines an alias (go template function) using the function (exec, run, include, template). Executed in the context of the caller. func alias(name string, function string, source interface{}, args ...interface{}) string, error  // Returns the list of all functions that are simply an alias of another function. func aliases() []string  // Returns the list of all available functions. func allFunctions() []string  // Raises a formated error if the test condition is false. // Aliases: assertion func assert(test interface{}, message ...interface{}) string, error  // Issues a formated warning if the test condition is false. // Aliases: assertw func assertWarning(test interface{}, message ...interface{}) string  // Returns all functions group by categories. // // The returned value has the following properties: // Name string // Functions []string func categories() []template.FuncCategory  // Returns the current folder (like pwd, but returns the folder of the currently running folder). func current() string  // Returns the result of the function by expanding its last argument that must be an array into values. It's like calling function(arg1, arg2, otherArgs...). func ellipsis(function string, args ...interface{}) interface{}, error  // Returns the result of the shell command as structured data (as string if no other conversion is possible). // Aliases: execute func exec(command interface{}, args ...interface{}) interface{}, error  // Exits the current program execution. func exit(exitValue int) int  // Defines a function with the current context using the function (exec, run, include, template). Executed in the context of the caller. func func(name string, function string, source interface{}, config interface{}) string, error  // Returns the information relative to a specific function. // // The returned value has the following properties: // Name string // Description string // Signature string // Group string // Aliases []string // Arguments string // Result string func function(name string) template.FuncInfo  // Returns the list of all available functions (excluding aliases). func functions() []string  // List all attributes accessible from the supplied object. // Aliases: attr, attributes func getAttributes(arg1 interface{}) string  // List all methods signatures accessible from the supplied object. // Aliases: methods func getMethods(arg1 interface{}) string  // List all attributes and methods signatures accessible from the supplied object. // Aliases: sign, signature func getSignature(arg1 interface{}) string  // Returns the result of the named template rendering (like template but it is possible to capture the output). func include(source interface{}, context ...interface{}) interface{}, error  // Defines an alias (go template function) using the function (exec, run, include, template). Executed in the context of the function it maps to. func localAlias(name string, function string, source interface{}, args ...interface{}) string, error  // Raise a formated error. // Aliases: raiseError func raise(args ...interface{}) string, error  // Returns the result of the shell command as string. func run(command interface{}, args ...interface{}) interface{}, error  // Applies the supplied regex substitute specified on the command line on the supplied string (see --substitute). func substitute(content string) string  // Returns the list of available templates names. func templateNames() []string  // Returns the list of available templates. func templates() []*template.Template  Sprig Cryptographic \u0026amp; Security, http://masterminds.github.io/sprig/crypto.html // Computes Adler-32 checksum. func adler32sum(input string) string  func buildCustomCert(arg1 string, arg2 string) sprig.certificate, error  func derivePassword(arg1 uint32, arg2 string, arg3 string, arg4 string, arg5 string) string  func genCA(arg1 string, arg2 int) sprig.certificate, error  // Generates a new private key encoded into a PEM block. Type should be: ecdsa, dsa or rsa func genPrivateKey(type string) string  func genSelfSignedCert(arg1 string, arg2 []interface{}, arg3 []interface{}, arg4 int) sprig.certificate, error  func genSignedCert(arg1 string, arg2 []interface{}, arg3 []interface{}, arg4 int, arg5 sprig.certificate) sprig.certificate, error  // Computes SHA1 digest. func sha1sum(input string) string  // Computes SHA256 digest. func sha256sum(input string) string  Sprig Date, http://masterminds.github.io/sprig/date.html // The ago function returns duration from time.Now in seconds resolution. func ago(date interface{}) string  // The date function formats a dat (https://golang.org/pkg/time/#Time.Format). func date(fmt string, date interface{}) string  // Same as date, but with a timezone. // Aliases: date_in_zone func dateInZone(fmt string, date interface{}, zone string) string  // The dateModify takes a modification and a date and returns the timestamp. // Aliases: date_modify func dateModify(fmt string, date time.Time) time.Time  // The htmlDate function formates a date for inserting into an HTML date picker input field. func htmlDate(date interface{}) string  // Same as htmlDate, but with a timezone. func htmlDateInZone(date interface{}, zone string) string  // The current date/time. Use this in conjunction with other date functions. func now() time.Time  // Converts a string to a date. The first argument is the date layout and the second the date string. If the string can’t be convert it returns the zero value. func toDate(fmt string, str string) time.Time  Sprig Default, http://masterminds.github.io/sprig/defaults.html func coalesce(args ...interface{}) interface{}  func compact(arg1 interface{}) []interface{}  func default(arg1 interface{}, args ...interface{}) interface{}  func empty(arg1 interface{}) bool  // Aliases: ternary func ternarySprig(arg1 interface{}, arg2 interface{}, arg3 bool) interface{}  // Aliases: toJson func toJsonSprig(arg1 interface{}) string  // Aliases: toPrettyJson func toPrettyJsonSprig(arg1 interface{}) string  Sprig Dictionnary, http://masterminds.github.io/sprig/dicst.html // Aliases: dict func dictSprig(args ...interface{}) map[string]interface{}  // Aliases: hasKey func hasKeySprig(arg1 map[string]interface{}, arg2 string) bool  // Aliases: keys func keysSprig(args ...map[string]interface{}) []string  // Aliases: list, tuple, tupleSprig func listSprig(args ...interface{}) []interface{}  // Merge two or more dictionaries into one, giving precedence from **right to left**, effectively overwriting values in the dest dictionary func mergeOverwrite(arg1 map[string]interface{}, args ...map[string]interface{}) interface{}  // Aliases: merge func mergeSprig(arg1 map[string]interface{}, args ...map[string]interface{}) interface{}  // Aliases: omit func omitSprig(arg1 map[string]interface{}, args ...string) map[string]interface{}  // Aliases: pick func pickSprig(arg1 map[string]interface{}, args ...string) map[string]interface{}  // Aliases: pluck func pluckSprig(arg1 string, args ...map[string]interface{}) []interface{}  // Aliases: set func setSprig(arg1 map[string]interface{}, arg2 string, arg3 interface{}) map[string]interface{}  // Aliases: unset func unsetSprig(arg1 map[string]interface{}, arg2 string) map[string]interface{}  // Aliases: values func valuesSprig(arg1 map[string]interface{}) []interface{}  Sprig Encoding, http://masterminds.github.io/sprig/encoding.html func b32dec(arg1 string) string  func b32enc(arg1 string) string  func b64dec(arg1 string) string  func b64enc(arg1 string) string  Sprig File Path, http://masterminds.github.io/sprig/paths.html func base(arg1 string) string  func clean(arg1 string) string  func dir(arg1 string) string  func ext(arg1 string) string  func isAbs(arg1 string) bool  Sprig Flow Control, http://masterminds.github.io/sprig/flow_control.html // Unconditionally returns an empty string and an error with the specified text. This is useful in scenarios where other conditionals have determined that template rendering should fail. func fail(arg1 string) string, error  Sprig General, http://masterminds.github.io/sprig/ // Simple hello by Sprig func hello() string  // Aliases: uuid, guid, GUID func uuidv4() string  Sprig List, http://masterminds.github.io/sprig/lists.html // Aliases: append, push, pushSprig func appendSprig(arg1 interface{}, arg2 interface{}) []interface{}  func first(arg1 interface{}) interface{}  // Aliases: has func hasSprig(arg1 interface{}, arg2 interface{}) bool  // Aliases: initial func initialSprig(arg1 interface{}) []interface{}  func last(arg1 interface{}) interface{}  // Aliases: prepend func prependSprig(arg1 interface{}, arg2 interface{}) []interface{}  // Aliases: rest func restSprig(arg1 interface{}) []interface{}  // Aliases: reverse func reverseSprig(arg1 interface{}) []interface{}  // Aliases: slice func sliceSprig(arg1 interface{}, args ...interface{}) interface{}  // Aliases: uniq func uniqSprig(arg1 interface{}) []interface{}  // Aliases: without func withoutSprig(arg1 interface{}, args ...interface{}) []interface{}  Sprig Mathematics, http://masterminds.github.io/sprig/math.html func add1(arg1 interface{}) int64  // Aliases: add func addSprig(args ...interface{}) int64  // Aliases: ceil func ceilSprig(arg1 interface{}) float64  // Aliases: div func divSprig(arg1 interface{}, arg2 interface{}) int64  // Aliases: floor func floorSprig(arg1 interface{}) float64  // Aliases: max, biggest, biggestSprig func maxSprig(arg1 interface{}, args ...interface{}) int64  // Aliases: min func minSprig(arg1 interface{}, args ...interface{}) int64  // Aliases: mod func modSprig(arg1 interface{}, arg2 interface{}) int64  // Aliases: mul func mulSprig(arg1 interface{}, args ...interface{}) int64  func round(arg1 interface{}, arg2 int, args ...float64) float64  // Aliases: sub func subSprig(arg1 interface{}, arg2 interface{}) int64  func untilStep(arg1 int, arg2 int, arg3 int) []int  Sprig OS, http://masterminds.github.io/sprig/defaults.html func env(arg1 string) string  func expandenv(arg1 string) string  Sprig Reflection, http://masterminds.github.io/sprig/reflection.html // Aliases: kindis func kindIs(arg1 string, arg2 interface{}) bool  // Aliases: kindof func kindOf(arg1 interface{}) string  // Aliases: typeis func typeIs(arg1 string, arg2 interface{}) bool  // Aliases: typeisLike func typeIsLike(arg1 string, arg2 interface{}) bool  // Aliases: typeof func typeOf(arg1 interface{}) string  Sprig Regex, http://masterminds.github.io/sprig/strings.html // Returns the first (left most) match of the regular expression in the input string. func regexFind(regex string, str string) string  // Returns a slice of all matches of the regular expression in the input string. func regexFindAll(regex string, str string, n int) []string  // Returns true if the input string matches the regular expression. func regexMatch(regex string, str string) bool  // Returns a copy of the input string, replacing matches of the Regexp with the replacement string replacement. Inside string replacement, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. func regexReplaceAll(regex string, str string, repl string) string  // Returns a copy of the input string, replacing matches of the Regexp with the replacement string replacement The replacement string is substituted directly, without using Expand. func regexReplaceAllLiteral(regex string, str string, repl string) string  // Slices the input string into substrings separated by the expression and returns a slice of the substrings between those expression matches. The last parameter n determines the number of substrings to return, where -1 means return all matches. func regexSplit(regex string, str string, n int) []string  Sprig String Slice, http://masterminds.github.io/sprig/string_slice.html func join(arg1 string, arg2 interface{}) string  func sortAlpha(arg1 interface{}) []string  func split(arg1 string, arg2 string) map[string]string  func splitList(arg1 string, arg2 string) []string  func splitn(arg1 string, arg2 int, arg3 string) map[string]string  func toStrings(arg1 interface{}) []string  Sprig Strings, http://masterminds.github.io/sprig/strings.html // Truncates a string with ellipses (...). func abbrev(width int, str string) string  // Abbreviates both sides with ellipses (...). func abbrevboth(left int, right int, str string) string  // Converts string from snake_case to CamelCase. func camelcase(str string) string  // Concatenates multiple strings together into one, separating them with spaces. func cat(args ...interface{}) string  // Tests to see if one string is contained inside of another. // Aliases: contains func containsSprig(substr string, str string) bool  // Tests whether a string has a given prefix. func hasPrefix(prefix string, str string) bool  // Tests whether a string has a given suffix. func hasSuffix(suffix string, str string) bool  // Indents every line in a given string to the specified indent width. This is useful when aligning multi-line strings. // Aliases: indent func indentSprig(spaces int, str string) string  // Given multiple words, takes the first letter of each word and combine. func initials(str string) string  // Convert string from camelCase to kebab-case. func kebabcase(str string) string  // Converts the entire string to lowercase. func lower(str string) string  // Same as the indent function, but prepends a new line to the beginning of the string. // Aliases: nindent func nindentSprig(spaces int, str string) string  // Removes all whitespace from a string. func nospace(str string) string  // Pluralizes a string. func plural(one string, many string, count int) string  // Wraps each argument with double quotes. func quote(str ...interface{}) string  // Generates random string with letters. func randAlpha(count int) string  // Generates random string with letters and digits. func randAlphaNum(count int) string  // Generates random string with ASCII printable characters. func randAscii(count int) string  // Generates random string with digits. func randNumeric(count int) string  // Repeats a string multiple times. // Aliases: repeat func repeatSprig(count int, str string) string  // Performs simple string replacement. func replace(old string, new string, src string) string  // Shuffle a string. func shuffle(str string) string  // Converts string from camelCase to snake_case. func snakecase(str string) string  // Wraps each argument with single quotes. func squote(args ...interface{}) string  // Get a substring from a string. func substr(start int, length int, str string) string  // Swaps the uppercase to lowercase and lowercase to uppercase. func swapcase(str string) string  // Converts to title case. func title(str string) string  // Converts any value to string. func toString(value interface{}) string  // Removes space from either side of a string. func trim(str string) string  // Removes given characters from the front or back of a string. // Aliases: trimall func trimAll(chars string, str string) string  // Trims just the prefix from a string if present. func trimPrefix(prefix string, str string) string  // Trims just the suffix from a string if present. func trimSuffix(suffix string, str string) string  // Truncates a string (and add no suffix). // Aliases: trunc func truncSprig(length int, str string) string  // Removes title casing. func untitle(str string) string  // Converts the entire string to uppercase. func upper(str string) string  // Wraps text at a given column count. // Aliases: wrap func wrapSprig(length int, str string) string  // Works as wrap, but lets you specify the string to wrap with (wrap uses \\n). func wrapWith(length int, spe string, str string) string  Sprig Type Conversion, http://masterminds.github.io/sprig/conversion.html func atoi(arg1 string) int  func float64(arg1 interface{}) float64  func int64(arg1 interface{}) int64  // Aliases: int func intSprig(arg1 interface{}) int  Sprig Version comparison, http://masterminds.github.io/sprig/semver.html // Parses a string into a Semantic Version. func semver(version string) *semver.Version, error  // A more robust comparison function is provided as semverCompare. This version supports version ranges. func semverCompare(constraints string, version string) bool, error  "},{"idx":7,"href":"/gotemplate/docs/features/arithmetic/","title":"Arithmetic","content":" Basic mathematic operations Operators mixin Note that you cannot combine razor extended expression (+, -, /, *, etc.) with go template expression such as in:\n   Razor expression Go Template Result Note     \u0026#64;(2 + (2 \u0026#124; mul(4))); \u0026#123;{ add 2 (bor 2 (mul 4)) }} 8 In this statement, \u0026#124; is interpreted as bitwise or between 2 and 4   \u0026#64;(sum 2 (2 \u0026#124; mul 4)); \u0026#123;{ sum 2 (2 \u0026#124; mul 4) }} 10 While in this statement (no binary operator), \u0026#124; is interpreted as go template piping operator    Addition    Razor expression Go Template Result Note     @(1 + 2); {{ add 1 2 }} 3 Addition   @add(4, 5); {{ add 4 5 }} 9 or add   @sum(6,7); {{ sum 6 7 }} 13 or sum   @(2+3); {{ add 2 3 }} 5 Spaces are optional   @( 8 + 9 ); {{ add 8 9 }} 17 You can insert an arbitrary number of spaces in expressions   @sum(1.2, 3.4); {{ sum 1.2 3.4 }} 4.6 It also works with floating point numbers   @sum(1, 2, 3, 4); {{ sum 1 2 3 4 }} 10 It is possible to supply multiple arguments to addition operation   @add(list(1,2,3,4)); {{ add (list 1 2 3 4) }} 10 this is useful on this line since there is ambiguity on where the expression finish    Subtraction    Razor expression Go Template Result Note     @(4 - 2); {{ sub 4 2 }} 2 Subtraction   @sub(4, 2); {{ sub 4 2 }} 2 or sub   @subtract(4, 2); {{ subtract 4 2 }} 2 or subtract    Negative values    Razor expression Go Template Result Note     @(-23); {{ -23 }} -23 Negative value   @(2 + -23); {{ add 2 -23 }} -21 Operation with negative value   @(2 + -(5 * 3)); {{ add 2 (sub 0 (mul 5 3)) }} -13 Operation with negative expression    Product    Razor expression Go Template Result Note     @(2 * 3); {{ mul 2 3 }} 6 Multiplication   @mul(4, 5); {{ mul 4 5 }} 20 or mul   @multiply(6, 7); {{ multiply 6 7 }} 42 or multiply   @prod(8, 9); {{ prod 8 9 }} 42 or prod   @product(10, 11); {{ product 10 11 }} 110 or product   @mul(1, 2, 3, 4); {{ mul 1 2 3 4 }} 24 It is possible to supply multiple arguments to multiplication operation   @mul(list(5,6,7,8)); {{ mul (list 5 6 7 8) }} 1680 or even an array    Division    Razor expression Go Template Result Note     @(4 / 2); {{ div 4 2 }} 2 Division   @(13 ÷ 3); {{ div 13 3 }} 4.333333333333333 you can use the ÷ character instead of /   @div(20, 4); {{ div 20 4 }} 5 or div   @divide(10, 4); {{ divide 10 4 }} 2.5 or divide   @quotient(22, 10); {{ quotient 22 10 }} 2.2 or quotient    modulo    Razor expression Go Template Result Note     @(4 % 3); {{ mod 4 3 }} 1 Modulo   @mod(12, 5); {{ mod 12 5 }} 2 or mod   @modulo(20, 6) {{ modulo 20 6 }} 2 or modulo    Power    Razor expression Go Template Result Note     @(4 ** 3); {{ pow 4 3 }} 64 Power   @pow(12, 5); {{ pow 12 5 }} 248832 or pow   @power(3, 8); {{ power 3 8 }} 6561 or power   @pow10(3); {{ pow10 3 }} 1000 Power 10   @power10(5); {{ power10 5 }} 100000 or power10   @(1e+5); {{ 1e+5 }} 100000 Scientific notation (positive)   @(2e-3); {{ 2e-3 }} 0.002 Scientific notation (negative)    Bit operators    Razor expression Go Template Result Note     @(1 \u0026lt;\u0026lt; 8); {{ lshift 1 8 }} 256 Left shift   @lshift(3, 5); {{ lshift 3 5 }} 96 or lshift   @leftShift(4, 4); {{ leftShift 4 4 }} 64 or leftShift   @(1024 \u0026gt;\u0026gt; 4); {{ rshift 1024 4 }} 64 Right shift   @rshift(456, 3); {{ rshift 456 3 }} 57 or rshift   @rightShift(72, 1); {{ rightShift 72 1 }} 36 or rightShift   @(65535 \u0026amp; 512); {{ band 65535 512 }} 512 Bitwise AND   @band(12345, 678); {{ band 12345 678 }} 32 or band   @bitwiseAND(222, 111); {{ bitwiseAND 222 111 }} 78 or bitwiseAND   @@(1 \u0026#124; 2 \u0026#124; 4); {{ bor (bor 1 2) 4 }} 7 Bitwise OR   @bor(100, 200, 300); {{ bor 100 200 300 }} 492 or bor   @bitwiseOR(64, 256, 4); {{ bitwiseOR 64 256 4 }} 324 *or bitwiseOR   @(1 ^ 2 ^ 4); {{ bxor (bxor 1 2) 4 }} 7 Bitwise XOR   @bxor(100, 200, 300); {{ bxor 100 200 300 }} 384 or bxor   @bitwiseXOR(64, 256, 4); {{ bitwiseXOR 64 256 4 }} 324 *or bitwiseXOR   @(255 \u0026amp;^ 4); {{ bclear 255 4 }} - Bitwise Clear   @bclear(0xff, 3, 8); {{ bclear 0xff 3 8 }} - or bclear   @bitwiseClear(0xf, 7); {{ bitwiseClear 0xf 7 }} - *or bitwiseClear    Other mathematic functions Special cases There are special behavior for certain operators depending of the arguments:\nString multiplication @(\u0026rdquo;*\u0026rdquo; * 100) will result in {{ mul \u0026ldquo;*\u0026rdquo; 100 }} which result in:\nMath operation on array "},{"idx":8,"href":"/gotemplate/docs/features/assignation/","title":"Assignation","content":" Assignation Global variables    Razor expression Go Template Note     @string := \u0026quot;string value\u0026quot;; {{- set $ \u0026quot;string\u0026quot; \u0026quot;string value\u0026quot; }} Global assignation of string   @numeric1 := 10; {{- set $ \u0026quot;numeric1\u0026quot; 10 }} Global assignation of integer   @numeric2 := 1.23; {{- set $ \u0026quot;numeric2\u0026quot; 1.23 }} Global assignation of floating point   @numeric3 := 4E+4; {{- set $ \u0026quot;numeric3\u0026quot; 4E+4 }} Global assignation of large scientific notation number   @numeric4 := 5E-3; {{- set $ \u0026quot;numeric4\u0026quot; 5E-3 }} Global assignation of small scientific notation number   @hexa1 := 0x100; {{- set $ \u0026quot;hexa1\u0026quot; 0x100 }} Global assignation of hexadecimal number   @result1 := (2+3)*4; {{- set $ \u0026quot;result1\u0026quot; (mul (add 2 3) 4) }} Global assignation of mathematic expression   @result2 := String(\u0026quot;hello world!\u0026quot;).Title; {{- set $ \u0026quot;result2\u0026quot; ((String \u0026quot;hello world!\u0026quot;).Title) }} Global assignation of generic expression    Local variables    Razor expression Go Template Note     @{string := \u0026quot;string value\u0026quot;} {{- $string := \u0026quot;string value\u0026quot; }} Local assignation of string   @{numeric1 := 10} {{- $numeric1 := 10 }} Local assignation of integer   @{numeric2 := 1.23} {{- $numeric2 := 1.23 }} Local assignation of floating point   @{numeric3 := 4E+4} {{- $numeric3 := 4E+4 }} Local assignation of large scientific number   @{numeric4 := 5E-3} {{- $numeric4 := 5E-3 }} Local assignation of small scientific number   @{hexa1 := 0x100} {{- $hexa1 := 0x100 }} Local assignation of hexadecimal number   @{result1 := (2+3)*4} {{- $result1 := mul (add 2 3) 4 }} Local assignation of mathematic expression   @{result2 := String(\u0026quot;hello world!\u0026quot;).Title} {{- $result2 := (String \u0026quot;hello world!\u0026quot;).Title }} Local assignation of generic expression    Exception    Razor expression Go Template Note     `@{invalid} := print \u0026ldquo;hello\u0026rdquo; \u0026ldquo;world\u0026rdquo; upper` `{{- $invalid := print }} \u0026ldquo;hello\u0026rdquo; \u0026ldquo;world\u0026rdquo;   `@{valid := print \u0026ldquo;hello\u0026rdquo; \u0026ldquo;world\u0026rdquo; upper}` `{{- $valid := print \u0026ldquo;hello\u0026rdquo; \u0026ldquo;world\u0026rdquo;   `@($valid := print \u0026ldquo;hello\u0026rdquo; \u0026ldquo;world\u0026rdquo; upper)` `{{- $valid := print \u0026ldquo;hello\u0026rdquo; \u0026ldquo;world\u0026rdquo;    Assignation within expression @-foreach ($value := to(10)) @{value} @-end foreach  @-foreach ($index, $value := to(10)) @{index} = @($value * 2) @-end foreach  @-if ($result := 2+2 == 4) result = @{result} @-end if  @-with ($value := 2+2) value = @{value} @-end with  "},{"idx":9,"href":"/gotemplate/docs/features/collections/","title":"Collections","content":" Data collections (lists/slices and dicts/maps) Maps    Razor Gotemplate Note     @razorDict := dict(\u0026quot;test\u0026quot;, 1, \u0026quot;test2\u0026quot;, 2); {{- set $ \u0026quot;goDict\u0026quot; (dict \u0026quot;test\u0026quot; 1 \u0026quot;test2\u0026quot; 2) }} Creation   @razorDict2 := dict(\u0026quot;test3\u0026quot;, 3, \u0026quot;test5\u0026quot;, 5); {{- set $ \u0026quot;goDict2\u0026quot; (dict \u0026quot;test3\u0026quot; 3 \u0026quot;test5\u0026quot; 5) }} Creation   @set(.razorDict, \u0026quot;test2\u0026quot;, 3); {{- set .goDict \u0026quot;test2\u0026quot; 3 }} Update   @set(.razorDict, \u0026quot;test3\u0026quot;, 4); {{- set .goDict \u0026quot;test3\u0026quot; 4 }} Update   @razorDict = merge(razorDict, razorDict2); {{- set $ \u0026quot;goDict\u0026quot; (merge .goDict .goDict2) }} Merge (First dict has priority)   @razorDict.test3; {{ $.goDict.test3 }} Should be 4   @razorDict.test5; {{ $.goDict.test5 }} Should be 5   @razorDict[\u0026quot;test\u0026quot;, \u0026quot;test3\u0026quot;, \u0026quot;undef\u0026quot;] {{ extract $.goDict \u0026quot;test\u0026quot; \u0026quot;test3\u0026quot; \u0026quot;undef\u0026quot; }} Extract values, should be [1,4,null]   @razorDict[\u0026quot;test\u0026quot;:\u0026quot;test9\u0026quot;] {{ slice $.goDict \u0026quot;test\u0026quot; \u0026quot;test9\u0026quot; }} Slice values, should be [1,3,4,5]   @razorDict[\u0026quot;test9\u0026quot;:\u0026quot;test\u0026quot;] {{ slice $.goDict \u0026quot;test9\u0026quot; \u0026quot;test\u0026quot; }} Slice values, should be [5,4,3,1]   @keys(razorDict) {{ keys $.goDict }} Get keys, should be [\u0026quot;test\u0026quot;,\u0026quot;test2\u0026quot;,\u0026quot;test3\u0026quot;,\u0026quot;test5\u0026quot;]   @values(razorDict) {{ values $.goDict }} Get values, should be [1,3,4,5]    Looping Razor @-foreach($key, $value := razorDict) @{key}, @{value}, @get($.razorDict, $key) @-end foreach  Gotemplate {{- range $key, $value := .goDict }} {{ $key }}, {{ $value }}, {{ get $.goDict $key }} {{- end }}  Result test, 1, 1 test2, 3, 3 test3, 4, 4 test5, 5, 5  Slices    Razor Gotemplate Note     @razorList := list(\u0026quot;test1\u0026quot;, \u0026quot;test2\u0026quot;, \u0026quot;test3\u0026quot;); {{- set $ \u0026quot;goList\u0026quot; (list \u0026quot;test1\u0026quot; \u0026quot;test2\u0026quot; \u0026quot;test3\u0026quot;) }} Creation   @razorList = append(razorList, \u0026quot;test4\u0026quot;); {{- set $ \u0026quot;goList\u0026quot; (append .goList \u0026quot;test4\u0026quot;) }} Append   @razorList = prepend(razorList, \u0026quot;test0\u0026quot;); {{- set $ \u0026quot;goList\u0026quot; (prepend .goList \u0026quot;test0\u0026quot;) }} Prepend   @razorList; {{ $.goList }} Should be [\u0026quot;test0\u0026quot;,\u0026quot;test1\u0026quot;,\u0026quot;test2\u0026quot;,\u0026quot;test3\u0026quot;,\u0026quot;test4\u0026quot;]   @contains(razorList, \u0026quot;test1\u0026quot;, \u0026quot;test2\u0026quot;); {{- contains .goList \u0026quot;test1\u0026quot; \u0026quot;test2\u0026quot; }} Check if element is in list   @has(\u0026quot;test1\u0026quot;, razorList); {{- has \u0026quot;test1\u0026quot; .goList }} has is an alias to contains   @has(razorList, \u0026quot;test1\u0026quot;); {{- has .goList \u0026quot;test1\u0026quot; }} has Support inversion of argument if the first one is not a list   @has(razorList, \u0026quot;test1\u0026quot;, \u0026quot;test2\u0026quot;); {{- has .goList \u0026quot;test1\u0026quot; \u0026quot;test2\u0026quot; }} has can also test for many elements   @razorList.Contains(\u0026quot;test1\u0026quot;, \u0026quot;test2\u0026quot;); {{ .goList.Contains \u0026quot;test1\u0026quot; \u0026quot;test2\u0026quot; }} List also support using methods   @razorList.Reverse(); {{ .goList.Reverse }} Should be [\u0026quot;test4\u0026quot;,\u0026quot;test3\u0026quot;,\u0026quot;test2\u0026quot;,\u0026quot;test1\u0026quot;,\u0026quot;test0\u0026quot;]    Looping Razor @-foreach($index, $value := razorList) @{index}, @{value}, @extract($.razorList, $index) @-end foreach  Gotemplate {{- range $index, $value := .goList }} {{ $index }}, {{ $value }}, {{ extract $.goList $index }} {{- end }}  Result 0, test0, test0 1, test1, test1 2, test2, test2 3, test3, test3 4, test4, test4  "},{"idx":10,"href":"/gotemplate/docs/features/comments/","title":"Comments","content":" Comments in gotemplate It is important to notice that gotemplate doesn\u0026rsquo;t know the language you are using and any identified gotemplate code is executed no matter where it is. Comments in the host language mean nothing to gotemplate and will be evaluated.\nPseudo comment If you insert gotemplate code into file that contains another kind of code such as hcl, json, yaml, xml, java, c# or any other language, your code editor or linter may complains because it will detect invalid characters.\nTo solve that problem, it is possible to inject pseudo comment into you code to hide the gotemplate code to your editor. The gotemplate is still interpretated, but obfuscated to the editor.\nIt is important to render code that is valid for the host language.\n #! is a pseudo comment that will removes the #! part but render everything after. //! is also used as pseudo comment and behave exactly as #!. /*@ @*/ is used to specify pseudo comment in a multi line context, everything inside is rendered, but /*@ and @*/ are removed.     Razor expression Go Template Render Note     # @(2+2) # {{ add 2 2 }} # 4 gotemplate code after # comment   // @(2+2) // {{ add 2 2 }} // 4 gotemplate code after // comment   /* @(2+2) */ /* {{ add 2 2 }} */ /* 4 */ gotemplate code within /* */ comment   #! @(2+2) {{ add 2 2 }} 4 Pseudo comment #!   //! @(2+2) {{ add 2 2 }} 4 Pseudo comment //!   /*@ @(2+2) @*/ {{ add 2 2 }} 4 Pseudo block comment with /@ @/    Real gotemplate comment If you really want to add comment to your file and wish them to not be rendered, you must use the following syntax.\n ##@ removes every character from ##@ up to the end of line. ///@ removes every character from //@ up to the end of line. @# generates gotemplate real comment {{/* comment */}} enclosing every character after the comment up to the end of line. @// acts exactly as @#. @/* */ is used to generates gotemplate comment in a multi-lines context.     Razor expression Go Template Render Note     @(2+2) ##@ comment @(2*3) {{ add 2 2 }} 4 Nothing is rendered after ##   @(2+2) ///@ comment @(2*3) {{ add 2 2 }} 4 Nothing is rendered after ///   @(2+2) @# comment @(2*3) {{ add 2 2 }} {{/* comment {{ mul 2 3 }} */}} 4 @# generates a real gotemplate comment   @(2+2) @// comment @(2*3) {{ add 2 2 }} {{/* comment {{ mul 2 3 }} */}} 4 @// also generates a real gotemplate comment   @(2+2) @/* comment @(2*3) */ {{ add 2 2 }} {{/* comment {{ mul 2 3 }} */}} 4 @/* */ is used to generate multi-lines gotemplate comment    Like most of the gotemplate razor syntax, you can add the minus sign to your @ command to render space eating gotemplate code.\n   Razor expression Go Template Note     @// Comment {{/* Comment */}} No space eater   @-// Comment {{- /* Comment */}} Left space eater   @_-// Comment {{/* Comment */ -}} Right space eaters   @--// Comment {{- /* Comment */ -}} Left and right space eaters    Examples Example with JSON code /*@ @{value} := 2 + 8 * 15 @*/ { \u0026quot;Str\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;Int\u0026quot;: 123, \u0026quot;Float\u0026quot;: 1.23, \u0026quot;PiAsString\u0026quot;: \u0026quot;@Math.Pi\u0026quot;, \u0026quot;ComputedAsString\u0026quot;: \u0026quot;@{value}\u0026quot;, /* You can use the special \u0026lt;\u0026lt; syntax to extract the value from the string delimiter */ \u0026quot;Pi\u0026quot;: \u0026quot;\u0026lt;\u0026lt;@Math.Pi\u0026quot;, \u0026quot;Computed\u0026quot;: \u0026quot;\u0026lt;\u0026lt;@{value}\u0026quot;, }  will give :\n{ \u0026quot;Str\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;Int\u0026quot;: 123, \u0026quot;Float\u0026quot;: 1.23, \u0026quot;PiAsString\u0026quot;: \u0026quot;3.141592653589793\u0026quot;, \u0026quot;ComputedAsString\u0026quot;: \u0026quot;122\u0026quot;, /* You can use the special \u0026lt;\u0026lt; syntax to extract the value from the string delimiter */ \u0026quot;Pi\u0026quot;: 3.141592653589793, \u0026quot;Computed\u0026quot;: 122, }  Example with HCL code #! @value := 2 + 8 * 15 Str = \u0026quot;string\u0026quot; Int = 123 Float = 1.23 PiAsString = \u0026quot;@Math.Pi\u0026quot; ComputedAsString = \u0026quot;@value\u0026quot; // You can use the special \u0026lt;\u0026lt; syntax to extract the value from the string delimiter Pi = \u0026quot;\u0026lt;\u0026lt;@Math.Pi\u0026quot; Computed = \u0026quot;\u0026lt;\u0026lt;@value\u0026quot;  will give:\nStr = \u0026quot;string\u0026quot; Int = 123 Float = 1.23 PiAsString = \u0026quot;3.141592653589793\u0026quot; ComputedAsString = \u0026quot;122\u0026quot; // You can use the special \u0026lt;\u0026lt; syntax to extract the value from the string delimiter Pi = 3.141592653589793 Computed = 122  "},{"idx":11,"href":"/gotemplate/docs/features/conditionals/","title":"Conditionals","content":" Conditionals in gotemplate #! @{is_true_1} := true #! @{is_true_2} := true #! @{is_false_1} := false #! @{is_false_2} := false #! @{false_string} := \u0026quot;false\u0026quot; #! @-if($is_true_1) TestTrue #! @-end #! @-if($is_false_1) TestFalse #! @-end #! @-if(and($is_true_1, $is_true_2)) TestTrueAndTrue #! @-end #! @-if(and($is_true_1, $is_false_1)) TestTrueAndFalse #! @-end #! @-if(or($is_true_1, $is_false_1)) TestTrueOrFalse #! @-end #! @-if($false_string) FalseStringIsTrue #! @-end  will give:\nTestTrue TestTrueAndTrue TestTrueOrFalse FalseStringIsTrue  "},{"idx":12,"href":"/gotemplate/docs/features/data/","title":"Data","content":" Data manipulation Using a data file with the following content in a format that doesn\u0026rsquo;t follow a standard.\nIntegerValue = 1 FloatValue = 1.23 StringValue = \u0026quot;Foo bar\u0026quot; EquationResult = @(2 + 2 * 3 ** 6) ListValue = [\u0026quot;value1\u0026quot;, \u0026quot;value2\u0026quot;] DictValue = {\u0026quot;key1\u0026quot;: \u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;: \u0026quot;value2\u0026quot;}  toYaml    Razor Gotemplate     @toYaml(data(\u0026quot;!Data\u0026quot;)) {{ toYaml (data \u0026quot;!Data\u0026quot;) }}    DictValue: key1: value1 key2: value2 EquationResult: 46658 FloatValue: 1.23 IntegerValue: 1 ListValue: - value1 - value2 StringValue: Foo bar  toJson    Razor Gotemplate     @toPrettyJson(data(\u0026quot;!Data\u0026quot;)) {{ toPrettyJson (data \u0026quot;!Data\u0026quot;) }}    { \u0026quot;DictValue\u0026quot;: { \u0026quot;key1\u0026quot;: \u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;: \u0026quot;value2\u0026quot; }, \u0026quot;EquationResult\u0026quot;: 46658, \u0026quot;FloatValue\u0026quot;: 1.23, \u0026quot;IntegerValue\u0026quot;: 1, \u0026quot;ListValue\u0026quot;: [ \u0026quot;value1\u0026quot;, \u0026quot;value2\u0026quot; ], \u0026quot;StringValue\u0026quot;: \u0026quot;Foo bar\u0026quot; }  toHcl    Razor Gotemplate     @toPrettyHcl(data(\u0026quot;!Data\u0026quot;)) {{ toPrettyHcl (data \u0026quot;!Data\u0026quot;) }}    EquationResult = 46658 FloatValue = 1.23 IntegerValue = 1 ListValue = [\u0026quot;value1\u0026quot;, \u0026quot;value2\u0026quot;] StringValue = \u0026quot;Foo bar\u0026quot; DictValue { key1 = \u0026quot;value1\u0026quot; key2 = \u0026quot;value2\u0026quot; }  Nested conversions This test shows how you can convert from and to other formats.\n   Razor Gotemplate     @toPrettyTFVars(data(toTFVars(fromHcl(toHcl(fromJson(toJson(data(\u0026quot;!Data\u0026quot;)))))))) {{ toPrettyTFVars (data (toTFVars (fromHcl (toHcl (fromJson (toJson (data \u0026quot;!Data\u0026quot;))))))) }}    EquationResult = 46658 FloatValue = 1.23 IntegerValue = 1 ListValue = [\u0026quot;value1\u0026quot;, \u0026quot;value2\u0026quot;] StringValue = \u0026quot;Foo bar\u0026quot; DictValue { key1 = \u0026quot;value1\u0026quot; key2 = \u0026quot;value2\u0026quot; }  Merging data structures This test shows how you can merge data structures\n{{- $dict_1 := data `{\u0026quot;dict\u0026quot;: {\u0026quot;string1\u0026quot;: \u0026quot;value1\u0026quot;, \u0026quot;string2\u0026quot;: \u0026quot;value2\u0026quot;}, \u0026quot;bool1\u0026quot;: true, \u0026quot;bool2\u0026quot;: false}` }} {{- $dict_2 := data `{\u0026quot;dict\u0026quot;: {\u0026quot;string1\u0026quot;: \u0026quot;value2\u0026quot;, \u0026quot;string3\u0026quot;: \u0026quot;value3\u0026quot;}, \u0026quot;bool1\u0026quot;: false, \u0026quot;bool3\u0026quot;: true}` }} # Gives precedence to the first dictionary @{dict_3} := merge($dict_1, $dict_2) @{dict_3.dict.string1} @typeOf($dict_3.dict.string1) == value1 string @{dict_3.dict.string2} @typeOf($dict_3.dict.string2) == value2 string @{dict_3.dict.string3} @typeOf($dict_3.dict.string3) == value3 string @{dict_3.bool1} @typeOf($dict_3.bool1) == true bool @{dict_3.bool2} @typeOf($dict_3.bool2) == false bool @{dict_3.bool3} @typeOf($dict_3.bool3) == true bool  "},{"idx":13,"href":"/gotemplate/docs/features/functions/","title":"Functions","content":" Functions Defining functions The following file is evaluated: !extensions.gte\nCalling functions Without arguments    Razor Gotemplate     @ChristmasTree() {{ ChristmasTree }}    Result  ✾ ✾✾✾ ✾✾✾✾✾ ✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾ ✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾✾  With arguments (colors not shown)    Razor Gotemplate     @ChristmasTree(5, \u0026quot;Red\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;a\u0026quot;) {{ ChristmasTree 5 \u0026quot;Red\u0026quot; \u0026quot;Green\u0026quot; \u0026quot;a\u0026quot; }}    Result  a aaa aaaaa aaaaaaa aaaaaaaaa  "},{"idx":14,"href":"/gotemplate/docs/features/literals/","title":"Literals","content":" Literals protection E-Mail protection The razor convertor is designed to detect email address such as john.doe@company.com or alert@127.0.0.1.\nBut it you type something like @john.doe@company.com, it will try to resolve variable john.doe and company.com.\nThe result would be \u0026lt;no value\u0026gt;\u0026lt;no value\u0026gt; unless you have defined:\n@john := data(\u0026quot;doe = 123.45\u0026quot;) @company := data(\u0026quot;com = @Math.Pi\u0026quot;)  In that case, the result of @john.doe@(company.com) will be 123.453.141592653589793.\n\u0026ldquo;\u0026#64;\u0026rdquo; protection You can also render the \u0026ldquo;\u0026#64;\u0026rdquo; characters by writing \u0026#64;\u0026#64;.\nSo this @@ will render \u0026#64;.\n\u0026ldquo;\u0026#123;\u0026#123;\u0026rdquo; protection You can also render \u0026ldquo;\u0026#123;\u0026#123;\u0026rdquo; without being interpretated by go template using the following syntax @{{.\nSo this @{{ will render \u0026#123;\u0026#123;.\nSpace management With go template, the way to indicate that previous or leading spaces between expression should be removed is expressed that way {{- \u0026quot;expression\u0026quot; -}}. The minus sign at the beginning and at the end mean that the spaces should be remove while {{- \u0026quot;expression\u0026quot; }} means to remove only at the beginning and {{ \u0026quot;expression\u0026quot; -}} means to remove only at the end.\nThe {{ \u0026quot;expression\u0026quot; }} will keep the spaces before and after expression as they are.\nWith razor, assignation will render go template code with - on left side.\n @expr := \u0026quot;expression\u0026quot; =\u0026gt; {{- set $ \u0026quot;expr\u0026quot; \u0026quot;expression\u0026quot; }} @{expr} := \u0026quot;expression\u0026quot; =\u0026gt; {{- $expr := \u0026quot;expression\u0026quot; }}  But for variables and other expressions, you have to specify the expected behavior.\n   Razor expression Go Template Note     @expr {{ $.expr }} No space eater   @-expr {{- $.expr }} Left space eater   @_-expr {{ $.expr -}} Right space eaters   @--expr {{- $.expr -}} Left and right space eaters    This signify that in the following sentence:\nThe word @expr will stay in the normal flow, but @-expr will be struck on the previous word  results in:\nThe word expression will stay in the normal flow, butexpression will be struck on the previous one  You can also specify that the expression should be preceded by a new line:\nThe word @\u0026lt;expr will be on a new line  results in:\nThe word expression will be on a new line  Indent using current indentation This line will be rendered with 4 spaces before each word:\n@autoIndent(wrap(15, \u0026quot;This is a long line that should be rendered with a maximum 15 characters per line\u0026quot;))  results in :\nThis is a long line that should be rendered with a maximum 15 characters per line  While this line will be rendered with 4 spaces and a caret before each word:\nlist: - @autoIndent(list(\u0026quot;item 1\u0026quot;, \u0026quot;item 2\u0026quot;, \u0026quot;item 3\u0026quot;)) - @autoIndent(list(\u0026quot;sub 1\u0026quot;, \u0026quot;sub 2\u0026quot;, \u0026quot;sub 3\u0026quot;))  results in:\n- item 1 - item 2 - item 3 - sub 1 - sub 2 - sub 3  While this line will be rendered with 4 spaces and ** before each word:\n** @autoIndent(list(\u0026quot;item 1\u0026quot;, \u0026quot;item 2\u0026quot;, \u0026quot;item 3\u0026quot;))  results in:\n** item 1 ** item 2 ** item 3  It is also possible to automatically wrap list elements with the surrounding context:\n=\u0026gt; This is Item #[@\u0026lt;autoWrap(to(5))]!  results in:\n=\u0026gt; This is Item #[1]! =\u0026gt; This is Item #[2]! =\u0026gt; This is Item #[3]! =\u0026gt; This is Item #[4]! =\u0026gt; This is Item #[5]!  "},{"idx":15,"href":"/gotemplate/docs/features/os-commands/","title":"Os Commands","content":" OS commands It is possible to run OS commands using the following go template functions:\n exec returns the result of a shell command as structured data. run returns the result of a shell command as a string.  exec Razor @{example} := exec(\u0026quot;printf 'SomeData: test2\\nSomeData2: test3'\u0026quot;) First result: @{example.SomeData} Second result: @{example.SomeData2} @{example} @{example2} := exec(\u0026quot;printf 'Test'\u0026quot;) Should be `string`: @typeOf($example2) @{example2}  Gotemplate {{- $example := exec \u0026quot;printf 'SomeData: test2\\nSomeData2: test3'\u0026quot; }} First result: {{ $example.SomeData }} Second result: {{ $example.SomeData2 }} {{ $example }} {{- $example2 := exec \u0026quot;printf 'Test'\u0026quot; }} Should be `string`: {{ typeOf $example2 }} {{ $example2 }}  Result First result: test2 Second result: test3 SomeData: test2 SomeData2: test3 Should be `string`: string Test  run Razor @{example} := run(\u0026quot;printf 'SomeData: test2\\nSomeData2: test3'\u0026quot;) Should be `string`: @typeOf($example) @{example}  Gotemplate {{- $example := run \u0026quot;printf 'SomeData: test2\\nSomeData2: test3'\u0026quot; }} Should be `string`: {{ typeOf $example }} {{ $example }}  Result Should be `string`: string SomeData: test2 SomeData2: test3  "},{"idx":16,"href":"/gotemplate/docs/features/templates/","title":"Templates","content":" Templates Defining templates Razor @-define(\u0026quot;razorTemplate\u0026quot;) This is a template with a variable here: @.var1 For each item in var2: @-for ($item := .var2) Print it: @$item @-end for @-end define  Gotemplate {{- define \u0026quot;goTemplate\u0026quot; }} This is a template with a variable here: {{ get . \u0026quot;var1\u0026quot; }} For each item in var2: {{- range $item := .var2 }} Print it: {{ $item }} {{- end }} {{- end }}  Using templates  @values := data(`{\u0026quot;var1\u0026quot;: \u0026quot;Test\u0026quot;, \u0026quot;var2\u0026quot;: [\u0026quot;Test1\u0026quot;, \u0026quot;Test2\u0026quot;]}`)     Razor Gotemplate     @template(\u0026quot;razorTemplate\u0026quot;, values) {{ template \u0026quot;goTemplate\u0026quot; .values }}    Result  This is a template with a variable here: Test For each item in var2: Print it: Test1 Print it: Test2  "},{"idx":17,"href":"/gotemplate/docs/structs/dict_methods/","title":"Dict Methods","content":"@Add(interface{}, interface{}) IDictionary AsMap() map[string]interface{} Clone(...interface{}) IDictionary Count() int Create(...int) IDictionary CreateList(...int) IGenericList Default(interface{}, interface{}) interface{} Delete(interface{}, ...interface{}) IDictionary, error Flush(...interface{}) IDictionary Get(...interface{}) interface{} GetHelpers() IDictionaryHelper, IListHelper GetKeys() IGenericList GetValues() IGenericList Has(...interface{}) bool KeysAsString() StringArray Len() int Merge(IDictionary, ...IDictionary) IDictionary Native() interface{} Omit(interface{}, ...interface{}) IDictionary Pop(...interface{}) interface{} PrettyPrint() string Set(interface{}, interface{}) IDictionary String() string Transpose() IDictionary TypeName() String  "},{"idx":18,"href":"/gotemplate/docs/structs/list_methods/","title":"List Methods","content":"@Append(...interface{}) IGenericList AsArray() []interface{} Cap() int Capacity() int Clone() IGenericList Contains(...interface{}) bool Count() int Create(...int) IGenericList CreateDict(...int) IDictionary First() interface{} Get(...int) interface{} GetHelpers() IDictionaryHelper, IListHelper Has(...interface{}) bool Intersect(...interface{}) IGenericList Join(interface{}) String Last() interface{} Len() int New(...interface{}) IGenericList Pop(...int) interface{}, IGenericList Prepend(...interface{}) IGenericList PrettyPrint() string Remove(...int) IGenericList Reverse() IGenericList Set(int, interface{}) IGenericList, error String() string StringArray() StringArray Strings() []string TypeName() String Union(...interface{}) IGenericList Unique() IGenericList Without(...interface{}) IGenericList  "},{"idx":19,"href":"/gotemplate/docs/structs/string_array_methods/","title":"String Array Methods","content":"Center(int) StringArray Indent(string) StringArray IndentN(int) StringArray Join(interface{}) String Sorted() StringArray Str() []string Strings() []string Title() StringArray ToLower() StringArray ToLowerSpecial(unicode.SpecialCase) StringArray ToTitle() StringArray ToTitleSpecial(unicode.SpecialCase) StringArray ToUpper() StringArray ToUpperSpecial(unicode.SpecialCase) StringArray Trim(string) StringArray TrimFunc(func(int32) bool) StringArray TrimLeft(string) StringArray TrimLeftFunc(func(int32) bool) StringArray TrimPrefix(string) StringArray TrimRight(string) StringArray TrimRightFunc(func(int32) bool) StringArray TrimSpace() StringArray TrimSuffix(string) StringArray UnIndent() StringArray Wrap(int) StringArray  "},{"idx":20,"href":"/gotemplate/docs/structs/string_methods/","title":"String Methods","content":"AddLineNumber(int) String Center(int) String Compare(string) int Contains(string) bool ContainsAny(string) bool ContainsRune(int32) bool Count(string) int EqualFold(string) bool Escape() String Fields() StringArray FieldsFunc(func(int32) bool) StringArray FieldsID() StringArray GetContextAtPosition(int, string, string) String, int GetWordAtPosition(int, ...string) String, int HasPrefix(string) bool HasSuffix(string) bool Indent(string) String IndentN(int) String Index(string) int IndexAll(string) []int IndexAny(string) int IndexByte(uint8) int IndexFunc(func(int32) bool) int IndexRune(int32) int Join(...interface{}) String LastIndex(string) int LastIndexAny(string) int LastIndexByte(uint8) int LastIndexFunc(func(int32) bool) int Len() int Lines() StringArray Map(func(int32) int32) String ParseBool() bool Protect() String, StringArray Quote() String Repeat(int) String Replace(string, string) String ReplaceN(string, string, int) String RestoreProtected(StringArray) String SelectContext(int, string, string) String SelectWord(int, ...string) String Split(string) StringArray SplitAfter(string) StringArray SplitAfterN(string, int) StringArray SplitN(string, int) StringArray Str() string String() string Title() String ToLower() String ToLowerSpecial(unicode.SpecialCase) String ToTitle() String ToTitleSpecial(unicode.SpecialCase) String ToUpper() String ToUpperSpecial(unicode.SpecialCase) String Trim(string) String TrimFunc(func(int32) bool) String TrimLeft(string) String TrimLeftFunc(func(int32) bool) String TrimPrefix(string) String TrimRight(string) String TrimRightFunc(func(int32) bool) String TrimSpace() String TrimSuffix(string) String UnIndent() String Wrap(int) String  "},{"idx":21,"href":"/gotemplate/categories/","title":"Categories","content":""},{"idx":22,"href":"/gotemplate/docs/","title":"Docs","content":""},{"idx":23,"href":"/gotemplate/tags/","title":"Tags","content":""}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();